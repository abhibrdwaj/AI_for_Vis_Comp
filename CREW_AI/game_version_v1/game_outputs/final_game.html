<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Orbitron', sans-serif;
            background-color: #1a1a2e;
            color: #ffffff;
        }
        .screen {
            display: none;
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }
        .screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .container {
            text-align: center;
            max-width: 600px;
            width: 90%;
        }
        button {
            background: linear-gradient(135deg, #283c86 0%, #45a247 100%);
            border: 2px solid #fff;
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            text-transform: uppercase;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            padding: 12px 30px;
            margin: 20px auto 0;
            display: block;
            width: 215.15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background: linear-gradient(135deg, #45a247 0%, #283c86 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        #hud {
            position: fixed;
            top: 50px;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
            padding: 10px;
            z-index: 100;
            display: none;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        #game-container {
            position: relative;
            width: 90vw;
            height: 60vw;
            max-width: 800px;
            max-height: 600px;
            background-color: #000;
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(15, 1fr);
        }
        .tile {
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        .visible {
            background-color: transparent;
        }
        .wall {
            background-color: #8B4513;
        }
        .player {
            background-color: #0f0;
        }
        .key {
            background-color: #ff0;
        }
        .door {
            background-color: #f00;
        }
        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
        }
        .dpad button {
            width: 60px;
            height: 60px;
            background-color: #555;
            color: white;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .dpad button:active {
            background-color: #777;
        }
        #start-menu-screen,
        #instructions-screen {
            background-image: url('../assets/torch_maze_bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: rgba(0, 0, 0, 0.75); /* Dark overlay */
            background-blend-mode: multiply;
        }
        .container {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 15px;
        }
        #game-controls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(26, 26, 46, 0.8);
            padding: 10px 0;
            z-index: 101;
            display: none; /* Ensure it is hidden initially */
            justify-content: center;
            gap: 10px;
        }
        #game-controls button {
            display: inline-block;
            width: auto;
            padding: 8px 15px;
            margin: 0 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="game-controls">
        <button id="game-menu-button">Menu</button>
        <button id="game-restart-button">Restart</button>
        <button id="game-instructions-button">Instructions</button>
    </div>
    <div id="hud">Keys: 0/3</div>

    <div id="start-menu-screen" class="active screen">
        <div class="container">
            <h1 id="game-title">Maze Game</h1>
            <button id="play-button">Play</button>
            <button id="instructions-button">Instructions</button>
        </div>
    </div>

    <div id="instructions-screen" class="screen">
        <div class="container">
            <h2>Instructions</h2>
            <p>Navigate through the maze, using keyboards (WASD) or touch controls</p>
            <p>Use Torchlight to explore the dark paths</p>
            <p>Collect 2-4 keys</p>
            <p>Then reach to the fixed red door!</p>
            <button id="instructions-back-button">Back</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div id="game-container"></div>
        <div class="dpad">
            <button id="up">↑</button>
            <button disabled></button>
            <button id="down">↓</button>
            <button id="left">←</button>
            <button disabled></button>
            <button id="right">→</button>
        </div>
    </div>

    <div id="game-over-screen" class="screen">
        <div class="container">
            <h2>Game Over</h2>
            <button id="play-again-button">Play Again</button>
            <button id="main-menu-button">Main Menu</button>
        </div>
    </div>



    <script>
        const TILE_SIZE = 40;
        const MAZE_WIDTH = 20;
        const MAZE_HEIGHT = 15;
        const totalKeys = 3;

        let keysCollected = 0;
        let playerPosition = { x: 1, y: 1 };
        let keyPositions = [];
        let doorPosition = { x: 18, y: 13 };

        const gameContainer = document.getElementById('game-container');
        const hud = document.getElementById('hud');

        // Get audio elements
        const gameBgm = document.getElementById('game-bgm');
        const keySound = document.getElementById('key-sound');
        const doorSound = document.getElementById('door-sound');

        function createMaze() {
            gameContainer.innerHTML = '';
            keyPositions = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    if (x === 0 || y === 0 || x === MAZE_WIDTH - 1 || y === MAZE_HEIGHT - 1 || Math.random() < 0.3) {
                        tile.classList.add('wall');
                    }
                    gameContainer.appendChild(tile);
                }
            }
            placePlayer();
            placeKeys();
            placeDoor();
            updateVisibility(); // Initially reveal only the tiles around the player
        }

        function placePlayer() {
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (MAZE_WIDTH - 2)) + 1,
                    y: Math.floor(Math.random() * (MAZE_HEIGHT - 2)) + 1
                };
                const index = position.y * MAZE_WIDTH + position.x;
                const tile = gameContainer.children[index];
                if (!tile.classList.contains('wall')) {
                    playerPosition = position;
                    tile.classList.add('player');
                    break;
                }
            } while (true);
        }

        function isReachable(start, target) {
            const visited = new Set();
            const queue = [start];
            const directions = [
                { x: 0, y: 1 },
                { x: 0, y: -1 },
                { x: 1, y: 0 },
                { x: -1, y: 0 }
            ];

            while (queue.length > 0) {
                const { x, y } = queue.shift();
                const key = `${x},${y}`;

                if (x === target.x && y === target.y) return true;
                if (visited.has(key)) continue;

                visited.add(key);

                directions.forEach(dir => {
                    const newX = x + dir.x;
                    const newY = y + dir.y;
                    const index = newY * MAZE_WIDTH + newX;
                    if (
                        newX >= 0 && newY >= 0 &&
                        newX < MAZE_WIDTH && newY < MAZE_HEIGHT &&
                        !visited.has(`${newX},${newY}`) &&
                        !gameContainer.children[index].classList.contains('wall')
                    ) {
                        queue.push({ x: newX, y: newY });
                    }
                });
            }

            return false;
        }

        function placeKeys() {
            for (let i = 0; i < totalKeys; i++) {
                let position;
                do {
                    position = {
                        x: Math.floor(Math.random() * (MAZE_WIDTH - 2)) + 1,
                        y: Math.floor(Math.random() * (MAZE_HEIGHT - 2)) + 1
                    };
                    const index = position.y * MAZE_WIDTH + position.x;
                    const tile = gameContainer.children[index];
                    if (
                        !tile.classList.contains('wall') &&
                        !keyPositions.some(k => k.x === position.x && k.y === position.y) &&
                        !(position.x === playerPosition.x && position.y === playerPosition.y) &&
                        isReachable(playerPosition, position)
                    ) {
                        keyPositions.push(position);
                        tile.classList.add('key');
                        break;
                    }
                } while (true);
            }
        }

        function placeDoor() {
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (MAZE_WIDTH - 2)) + 1,
                    y: Math.floor(Math.random() * (MAZE_HEIGHT - 2)) + 1
                };
                const index = position.y * MAZE_WIDTH + position.x;
                const tile = gameContainer.children[index];
                if (
                    !tile.classList.contains('wall') &&
                    !keyPositions.some(k => k.x === position.x && k.y === position.y) &&
                    !(position.x === playerPosition.x && position.y === playerPosition.y) &&
                    isReachable(playerPosition, position)
                ) {
                    doorPosition = position;
                    tile.classList.add('door');
                    break;
                }
            } while (true);
        }

        function movePlayer(dx, dy) {
            const newX = playerPosition.x + dx;
            const newY = playerPosition.y + dy;

            if (newX < 0 || newY < 0 || newX >= MAZE_WIDTH || newY >= MAZE_HEIGHT) {
                return;
            }

            const index = newY * MAZE_WIDTH + newX;
            const tile = gameContainer.children[index];

            if (!tile.classList.contains('wall')) {
                const oldIndex = playerPosition.y * MAZE_WIDTH + playerPosition.x;
                gameContainer.children[oldIndex].classList.remove('player');
                playerPosition = { x: newX, y: newY };
                tile.classList.add('player');
                checkKeyCollision();
                checkDoorCollision();
                updateVisibility(); // Update visibility after moving
            }
        }

        function updateVisibility() {
            // Reset all tiles to hidden (black)
            Array.from(gameContainer.children).forEach(tile => {
                tile.classList.remove('visible');
                tile.style.backgroundColor = '#000'; // Ensure all tiles are black by default
            });

            // Make the player's tile and 8 surrounding tiles visible
            const directions = [
                { x: 0, y: 0 }, // Player's current position
                { x: 1, y: 0 },
                { x: -1, y: 0 },
                { x: 0, y: 1 },
                { x: 0, y: -1 },
                { x: 1, y: 1 },
                { x: -1, y: -1 },
                { x: 1, y: -1 },
                { x: -1, y: 1 }
            ];

            directions.forEach(dir => {
                const x = playerPosition.x + dir.x;
                const y = playerPosition.y + dir.y;
                if (x >= 0 && y >= 0 && x < MAZE_WIDTH && y < MAZE_HEIGHT) {
                    const index = y * MAZE_WIDTH + x;
                    const tile = gameContainer.children[index];
                    tile.classList.add('visible');

                    // Restore the original color for visible tiles
                    if (tile.classList.contains('wall')) {
                        tile.style.backgroundColor = '#8B4513'; // Brown for walls
                    } else if (tile.classList.contains('key')) {
                        tile.style.backgroundColor = '#ff0'; // Yellow for keys
                    } else if (tile.classList.contains('door')) {
                        tile.style.backgroundColor = '#f00'; // Red for door
                    } else if (tile.classList.contains('player')) {
                        tile.style.backgroundColor = '#0f0'; // Green for player
                    } else {
                        tile.style.backgroundColor = 'transparent'; // Transparent for empty tiles
                    }
                }
            });

            // Ensure keys and door are always visible
            keyPositions.forEach(key => {
                const index = key.y * MAZE_WIDTH + key.x;
                const tile = gameContainer.children[index];
                tile.style.backgroundColor = '#ff0'; // Yellow for keys
            });

            const doorIndex = doorPosition.y * MAZE_WIDTH + doorPosition.x;
            const doorTile = gameContainer.children[doorIndex];
            doorTile.style.backgroundColor = '#f00'; // Red for door
        }

        // Play key sound when a key is collected
        function checkKeyCollision() {
            const keyIndex = keyPositions.findIndex(
                k => k.x === playerPosition.x && k.y === playerPosition.y
            );
            if (keyIndex !== -1) {
                const keyPosition = keyPositions[keyIndex];
                const index = keyPosition.y * MAZE_WIDTH + keyPosition.x;
                const tile = gameContainer.children[index];
                tile.classList.remove('key');
                keyPositions.splice(keyIndex, 1);
                keysCollected++;
                hud.innerText = `Keys: ${keysCollected}/${totalKeys}`;

                // Play key sound
                keySound.currentTime = 0; // Reset sound to the beginning
                keySound.play();
            }
        }

        // Play door sound when the player reaches the door with all keys
        function checkDoorCollision() {
            if (
                playerPosition.x === doorPosition.x &&
                playerPosition.y === doorPosition.y &&
                keysCollected === totalKeys
            ) {
                // Play door sound
                doorSound.currentTime = 0; // Reset sound to the beginning
                doorSound.play();

                alert('You Win! You escaped the maze!');
                keysCollected = 0;
                playerPosition = { x: 1, y: 1 };
                createMaze();
            }
        }

        function resetGame() {
            keysCollected = 0; // Reset key count
            hud.innerText = `Keys: ${keysCollected}/${totalKeys}`; // Update HUD
            playerPosition = { x: 1, y: 1 }; // Reset player position
            createMaze(); // Recreate the maze
        }

        document.addEventListener('keydown', event => {
            if (event.key === 'ArrowUp') movePlayer(0, -1);
            if (event.key === 'ArrowDown') movePlayer(0, 1);
            if (event.key === 'ArrowLeft') movePlayer(-1, 0);
            if (event.key === 'ArrowRight') movePlayer(1, 0);
        });

        document.getElementById('up').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('down').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('left').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('right').addEventListener('click', () => movePlayer(1, 0));

        document.addEventListener('DOMContentLoaded', () => {
            const hud = document.getElementById('hud');
            const startMenuScreen = document.getElementById('start-menu-screen');
            const instructionsScreen = document.getElementById('instructions-screen');
            const gameScreen = document.getElementById('game-screen');
            const gameOverScreen = document.getElementById('game-over-screen');

            const playButton = document.getElementById('play-button');
            const instructionsButton = document.getElementById('instructions-button');
            const instructionsBackButton = document.getElementById('instructions-back-button');
            const playAgainButton = document.getElementById('play-again-button');
            const mainMenuButton = document.getElementById('main-menu-button');

            const gameMenuButton = document.getElementById('game-menu-button');
            const gameRestartButton = document.getElementById('game-restart-button');
            const gameInstructionsButton = document.getElementById('game-instructions-button');

            const backgroundAudio = document.getElementById('background-audio');

            // Ensure audio plays even if autoplay is restricted
            const playAudio = () => {
                backgroundAudio.volume = 0.5; // Set volume to 50%
                backgroundAudio.play().catch(() => {
                    console.log('Autoplay was blocked. Waiting for user interaction.');
                });
            };

            // Attempt to play audio on page load
            playAudio();

            // Add a fallback to play audio on user interaction
            document.body.addEventListener('click', playAudio, { once: true });

            function swapToScreen(screen) {
                startMenuScreen.classList.remove('active');
                instructionsScreen.classList.remove('active');
                gameScreen.classList.remove('active');
                gameOverScreen.classList.remove('active');
                screen.classList.add('active');

                const gameControls = document.getElementById('game-controls');
                const hud = document.getElementById('hud');

                if (screen.id === 'game-screen') {
                    hud.style.display = 'block';
                    gameControls.style.display = 'flex'; // Ensure game controls are visible
                } else {
                    hud.style.display = 'none';
                    gameControls.style.display = 'none'; // Hide game controls on other screens
                }
            }

            playButton.addEventListener('click', () => {

            instructionsButton.addEventListener('click', () => swapToScreen(instructionsScreen));
            instructionsBackButton.addEventListener('click', () => swapToScreen(startMenuScreen));
            playAgainButton.addEventListener('click', () => {
                resetGame();
                swapToScreen(gameScreen);
            });
            mainMenuButton.addEventListener('click', () => swapToScreen(startMenuScreen));

            gameMenuButton.addEventListener('click', () => swapToScreen(startMenuScreen));
            gameRestartButton.addEventListener('click', resetGame);
            gameInstructionsButton.addEventListener('click', () => {
                swapToScreen(instructionsScreen);
                instructionsBackButton.addEventListener('click', () => swapToScreen(gameScreen), { once: true });
            });

            // Initialize the game by showing the start menu
            swapToScreen(document.getElementById('start-menu-screen'));

            createMaze();
        });
    </script>
</body>
</html>
